{"version":3,"sources":["index.js","../lib/index.ts"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","redis_1","require","Redis","constructor","url","_client","default","createClient","_url","_connected","addListener","status","connected","mounted","setKey","key","Array","isArray","assign","serialised","JSON","stringify","set","err","reply","getByKey","get","ret","found","data","parse","getByKeys","keys","all","map","getKeys","prefix","replies","deleteKey","del","lazyCache","callback","fresh","module"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst redis_1 = require(\"redis\");\n;\nclass Redis {\n    /**\n     * Create a promisified wrapper around Redis\n     * @param url Where redis is mounted\n     */\n    constructor(url) {\n        this._client = redis_1.default.createClient(url);\n        this._url = url;\n        this._connected = false;\n        this._client.addListener('connect', () => this._connected = true);\n    }\n    get status() {\n        return {\n            connected: this._connected,\n            mounted: this._url,\n        };\n    }\n    /**\n     * Set a key-stringified-value pair in ur store\n     * @param key Key to store value under\n     * @param value JSON value to store within redis\n     */\n    setKey(key, value) {\n        return new Promise((resolve, reject) => {\n            // if we just want to store a value, don't bother adding a key\n            if (!Array.isArray(value))\n                Object.assign(value, { key });\n            const serialised = JSON.stringify(value);\n            this._client.set(key, serialised, (err, reply) => {\n                if (err)\n                    return reject(err);\n                resolve(reply);\n            });\n        });\n    }\n    /**\n     * Get data from redis and parse to JSON\n     * @param key data stored by this key\n     */\n    getByKey(key) {\n        return new Promise((resolve, reject) => {\n            this._client.get(key, (err, reply) => {\n                if (err)\n                    return reject(err);\n                const ret = { found: false, data: '' };\n                if (reply) {\n                    ret.found = true;\n                    ret.data = JSON.parse(reply);\n                }\n                resolve(ret);\n            });\n        });\n    }\n    /**\n     * Asynchronously get a load of data from redis\n     * @param keys Any number of keys to retrieve\n     */\n    getByKeys(...keys) {\n        return Promise.all(keys.map(this.getByKey));\n    }\n    /**\n     * Promise wrapper to get corresponding keys from Redis\n     * @param {string} key Key prefix for Redis\n     */\n    getKeys(prefix = '') {\n        return new Promise((resolve, reject) => {\n            this._client.keys(prefix, (err, replies) => {\n                if (err)\n                    return reject(err);\n                const ret = { found: false, data: [] };\n                if (replies) {\n                    ret.found = true;\n                    ret.data = replies;\n                }\n                resolve(ret);\n            });\n        });\n    }\n    /**\n     * Promise wrapper for redis.delKey\n     * @param {string} key key to remove from redis\n     */\n    deleteKey(key) {\n        return new Promise(resolve => this._client.del(key, resolve));\n    }\n    /**\n     * lazy caching\n     * Have we found something? great, resolve and then update the cache\n     * Not found? get fresh data, and then add it to the cache\n     * Promises don't exit upon resolve\n     *  -- JavaScript only does this when it throws an error, or returns something\n     * @param {function} callback MUST BE A FUNCTION THAT RETURNS A PROMISE. function to get data\n     * @param {string} key used to set and retrieve data from redis\n     */\n    lazyCache(key, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data, found } = yield this.getByKey(key);\n            return new Promise(resolve => {\n                if (found) {\n                    resolve(data);\n                    // by not awaiting, we're not blocking the software\n                    callback().then(fresh => this.setKey(key, fresh));\n                }\n                else {\n                    // tricky. get fresh data and resolve the *original* promise\n                    // then, set the key\n                    callback().then(fresh => {\n                        resolve(fresh);\n                        this.setKey(key, fresh);\n                    });\n                }\n            });\n        });\n    }\n}\nmodule.exports = Redis;\n","import redis, { RedisClient } from 'redis';\n\n// piece of data stored in redis\ninterface Stored {\n  found: boolean,\n  data: any,\n};\n\n// list of keys\ninterface ReturnedKeys {\n  found: boolean,\n  data: string[];\n}\n\n// current status\ninterface Status {\n  connected: Boolean,\n  mounted: string,\n}\n\nclass Redis {\n  _client: RedisClient;\n  _url: string;\n  _connected: Boolean; \n\n  /**\n   * Create a promisified wrapper around Redis\n   * @param url Where redis is mounted\n   */\n  constructor(url: string) {\n    this._client = redis.createClient(url);\n    this._url = url;\n    this._connected = false;\n    this._client.addListener('connect', () => this._connected = true);\n  }\n\n  get status(): Status {\n    return {\n      connected: this._connected,\n      mounted: this._url,\n    };\n  }\n\n  /**\n   * Set a key-stringified-value pair in ur store\n   * @param key Key to store value under\n   * @param value JSON value to store within redis\n   */\n  setKey(key: string, value: object): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // if we just want to store a value, don't bother adding a key\n      if (!Array.isArray(value)) Object.assign(value, { key });\n      const serialised: string = JSON.stringify(value);\n      this._client.set(key, serialised, (err, reply) => {\n        if (err) return reject(err);\n        resolve(reply);\n      });\n    });\n  }\n\n  /**\n   * Get data from redis and parse to JSON\n   * @param key data stored by this key \n   */\n  getByKey(key: string): Promise<Stored> {\n    return new Promise((resolve, reject) => {\n      this._client.get(key, (err, reply) => {\n        if (err) return reject(err);\n        const ret: Stored = { found: false, data: '' };\n        if (reply) {\n          ret.found = true;\n          ret.data = JSON.parse(reply);\n        }\n        resolve(ret);\n      });\n    });\n  }\n\n  /**\n   * Asynchronously get a load of data from redis\n   * @param keys Any number of keys to retrieve\n   */\n  getByKeys(...keys: string[]): Promise<Array<object>> {\n    return Promise.all(keys.map(this.getByKey));\n  }\n\n  /**\n   * Promise wrapper to get corresponding keys from Redis\n   * @param {string} key Key prefix for Redis\n   */\n  getKeys(prefix: string = ''): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this._client.keys(prefix, (err, replies) => {\n        if (err) return reject(err);\n        const ret: ReturnedKeys = { found: false, data: [] };\n        if (replies) {\n          ret.found = true;\n          ret.data = replies;\n        }\n        resolve(ret);\n      });\n    });\n  }\n\n  /**\n   * Promise wrapper for redis.delKey\n   * @param {string} key key to remove from redis\n   */\n  deleteKey(key: string): Promise<any> {\n    return new Promise(resolve => this._client.del(key, resolve));\n  }\n\n  /**\n   * lazy caching\n   * Have we found something? great, resolve and then update the cache\n   * Not found? get fresh data, and then add it to the cache\n   * Promises don't exit upon resolve\n   *  -- JavaScript only does this when it throws an error, or returns something\n   * @param {function} callback MUST BE A FUNCTION THAT RETURNS A PROMISE. function to get data\n   * @param {string} key used to set and retrieve data from redis\n   */\n  async lazyCache(key: string, callback: Function): Promise<any> {\n    const { data, found }: Stored = await this.getByKey(key);\n    return new Promise(resolve => {\n      if (found) {\n        resolve(data);\n        // by not awaiting, we're not blocking the software\n        callback().then(fresh => this.setKey(key, fresh));\n      } else {\n        // tricky. get fresh data and resolve the *original* promise\n        // then, set the key\n        callback().then(fresh => {\n          resolve(fresh);\n          this.setKey(key, fresh);\n        });\n      }\n    });\n  }\n}\n\nmodule.exports = Redis;"]}