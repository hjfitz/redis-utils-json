{"version":3,"sources":["../lib/index.ts","index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Redis","constructor","url","client","createClient","setKey","key","Array","isArray","Object","assign","serialised","JSON","stringify","set","err","reply","getByKey","get","ret","found","data","getKeys","prefix","keys","replies","deleteKey","del","lazyCache","callback","fresh"],"mappings":"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","file":"index.js","sourcesContent":["import redis, { RedisClient } from 'redis';\n\n// interface for returning a piece of data\ninterface Stored {\n  found: boolean,\n  data: any,\n};\n\n// interface for returning a list of keys\ninterface RetKeys {\n  found: boolean,\n  data: string[];\n}\n\n\nexport default class Redis {\n  client: RedisClient;\n\n  /**\n   * Create a promisified wrapper around Redis\n   * @param url Where redis is mounted\n   */\n  constructor(url: string) {\n    this.client = redis.createClient(url);\n  }\n\n\n  /**\n   * Set a key-stringified-value pair in ur store\n   * @param key Key to store value under\n   * @param value JSON value to store within redis\n   */\n  setKey(key: string, value: object): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // if we just want to store a value, don't bother adding a key\n      if (!Array.isArray(value)) Object.assign(value, { key });\n      const serialised: string = JSON.stringify(value);\n      this.client.set(key, serialised, (err, reply) => {\n        if (err) return reject(err);\n        resolve(reply);\n      });\n    });\n  }\n\n  getByKey(key: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.client.get(key, (err, reply) => {\n        if (err) return reject(err);\n        const ret: Stored = { found: false, data: '' };\n        if (reply) {\n          ret.found = true;\n          ret.data = reply;\n        }\n        resolve(ret);\n      });\n    });\n  }\n\n  /**\n   * Promise wrapper to get corresponding keys from Redis\n   * @param {string} key Key prefix for Redis\n   */\n  getKeys(prefix: string = ''): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.client.keys(prefix, (err, replies) => {\n        if (err) return reject(err);\n        const ret: RetKeys = { found: false, data: [] };\n        if (replies) {\n          ret.found = true;\n          ret.data = replies;\n        }\n        resolve(ret);\n      });\n    });\n  }\n\n  /**\n   * Promise wrapper for redis.delKey\n   * @param {string} key key to remove from redis\n   */\n  deleteKey(key: string): Promise<any> {\n    return new Promise(resolve => this.client.del(key, resolve));\n  }\n\n  /**\n   * lazy caching\n   * Have we found something? great, resolve and then update the cache\n   * Not found? get fresh data, and then add it to the cache\n   * Promises don't exit upon resolve\n   *  -- JavaScript only does this when it throws an error, or returns something\n   * @param {function} callback function to get data\n   * @param {string} key used to set and retrieve data from redis\n   */\n  async lazyCache(key: string, callback: Function): Promise<any> {\n    const { data, found }: Stored = await this.getByKey(key);\n    return new Promise(resolve => {\n      if (found) {\n        resolve(data);\n        // by not awaiting, we're not blocking the software\n        callback().then(fresh => this.setKey(key, fresh));\n      } else {\n        // tricky. get fresh data and resolve the *original* promise\n        // then, set the key\n        callback().then(fresh => {\n          resolve(fresh);\n          this.setKey(key, fresh);\n        });\n      }\n    });\n  }\n}","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport redis from 'redis';\n;\nexport default class Redis {\n    /**\n     * Create a promisified wrapper around Redis\n     * @param url Where redis is mounted\n     */\n    constructor(url) {\n        this.client = redis.createClient(url);\n    }\n    /**\n     * Set a key-stringified-value pair in ur store\n     * @param key Key to store value under\n     * @param value JSON value to store within redis\n     */\n    setKey(key, value) {\n        return new Promise((resolve, reject) => {\n            // if we just want to store a value, don't bother adding a key\n            if (!Array.isArray(value))\n                Object.assign(value, { key });\n            const serialised = JSON.stringify(value);\n            this.client.set(key, serialised, (err, reply) => {\n                if (err)\n                    return reject(err);\n                resolve(reply);\n            });\n        });\n    }\n    getByKey(key) {\n        return new Promise((resolve, reject) => {\n            this.client.get(key, (err, reply) => {\n                if (err)\n                    return reject(err);\n                const ret = { found: false, data: '' };\n                if (reply) {\n                    ret.found = true;\n                    ret.data = reply;\n                }\n                resolve(ret);\n            });\n        });\n    }\n    /**\n     * Promise wrapper to get corresponding keys from Redis\n     * @param {string} key Key prefix for Redis\n     */\n    getKeys(prefix = '') {\n        return new Promise((resolve, reject) => {\n            this.client.keys(prefix, (err, replies) => {\n                if (err)\n                    return reject(err);\n                const ret = { found: false, data: [] };\n                if (replies) {\n                    ret.found = true;\n                    ret.data = replies;\n                }\n                resolve(ret);\n            });\n        });\n    }\n    /**\n     * Promise wrapper for redis.delKey\n     * @param {string} key key to remove from redis\n     */\n    deleteKey(key) {\n        return new Promise(resolve => this.client.del(key, resolve));\n    }\n    /**\n     * lazy caching\n     * Have we found something? great, resolve and then update the cache\n     * Not found? get fresh data, and then add it to the cache\n     * Promises don't exit upon resolve\n     *  -- JavaScript only does this when it throws an error, or returns something\n     * @param {function} callback function to get data\n     * @param {string} key used to set and retrieve data from redis\n     */\n    lazyCache(key, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data, found } = yield this.getByKey(key);\n            return new Promise(resolve => {\n                if (found) {\n                    resolve(data);\n                    // by not awaiting, we're not blocking the software\n                    callback().then(fresh => this.setKey(key, fresh));\n                }\n                else {\n                    // tricky. get fresh data and resolve the *original* promise\n                    // then, set the key\n                    callback().then(fresh => {\n                        resolve(fresh);\n                        this.setKey(key, fresh);\n                    });\n                }\n            });\n        });\n    }\n}\n"]}